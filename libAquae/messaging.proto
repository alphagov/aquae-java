////////////////////////////////////////////////////////////////////////////////
// AUTOGENERATED by md2protobf
// AUTOGENERATED ***DO NOT EDIT***
// AUTOGENERATED from messaging.md on 2017-08-29T13:02:31Z
////////////////////////////////////////////////////////////////////////////////



// messaging.md:5
    syntax = "proto2";
    package Aquae.Messaging;
    option java_package           = "uk.gov.Aquae.ProtocolBuffers";
    option java_outer_classname   = "Messaging";
    option java_multiple_files    = false;
    option java_string_check_utf8 = true;
    option java_generic_services  = false;


// messaging.md:41
  message IdentitySignRequest {
    optional PersonIdentity subjectIdentity = 1;
    // TODO: also need to send the query that we want to run. Then identity bridge verifies.
    repeated string identitySetNodes = 2;
  }

  message PersonIdentity {
    optional string surname = 1;
    optional string postcode = 2;
    optional int32  birthYear = 3;
    optional string initials = 4; // Initials in little endian Western order
    optional string houseNumber = 6;
    optional string dateOfBirth = 7; // As an RFC-3339 date
  }

  message AgentIdentity {
    // TODO: identity of an agent/client
  }

  message ServiceIdentity {
    // TODO: identity of the service making the request
  }

  message SignedIdentity {
    // TODO: unecrpyted container containing Redactable<T> fields
    // ID bridge cannot leave fields empty -> all are required
  }


// messaging.md:75
    /* The pattern for signed messages is:
    message Signed<T> {
      optional T payload = 1;
      optional bytes signature = 2;
    }
    */

    message Question {
      optional string name = 1;
      // repeated Param inputs = 2; TODO: way of expressing this TBC
      optional string dsaId = 9; // TODO: interesting that this has ended up here. is it a dragon?
    }

    message Choice {
      repeated string requiredQuery = 1;
    }

    message Query {
      optional Question question = 1;
      optional bytes queryId = 2;
      optional SignedScope scope = 3;

      // The transaction-id of the scope is the digest. TODO: algorithm.
      message Scope {
        optional Question originalQuestion = 1;
        optional bytes nOnce = 2; // Monotonically increasing value set by CS
        optional SignedIdentity subjectIdentity = 3;
        optional PersonIdentity delegateIdentity = 4;
        optional AgentIdentity agentIdentity = 5;
        optional ServiceIdentity serviceIdentity = 6;
        repeated Choice choice = 7;
      }

      message SignedScope {
        optional Scope scope = 1;
        optional bytes signature = 2;
      }
    }

    /* The pattern for redactable data structures is:
    message Redactable<T> {
      message RealValue {
        optional int salt = 1;
        optional T value = 2;
      }

      message EncryptedValue {
        optional bytes hash = 1;
        optional bytes blob = 2;
      }

      oneof {
        optional bytes hash = 1;
        optional RealValue value = 2;
        optional EncryptedValue encrypted = 3;
      }
    }
    */

    /* The pattern for redactable containers is:
    message RedactableContainer<T> {
      optional T message = 1;
      optional bytes rootHash = 2;
      optional bytes signatureOfHash = 3;
      optional map<string, bytes> nodeKeys = 4;
    }
    */

    message SignedQuery {
      optional Query query = 1;
      optional bytes signature = 2;
    }


// messaging.md:165
    message BadQueryResponse {
      enum Reason {
        StaleMetadata = 0;
        CannotAnswerQuery = 1;
        ServiceUnauthorized = 2;
        NoConsentToken = 3;
        AgentUnauthorized = 4;
        DelegateUnauthorized = 5;
        MissingIdentity = 6;
        IdentityTooOpen = 7;
        MissingIdentityFields = 8;
      } // TODO: NCSC: how detailed is this in non-debug?

      optional bytes queryId = 1;
      optional Reason reason = 2;
    }


// messaging.md:194
    message QueryResponse {
      optional bytes queryId = 1;
      oneof result {
        MoreIdentityResponse moreIdentityResponse = 3;
        MatchCompleteResponse matchCompleteResponse = 4;
      }
    }


// messaging.md:208
      message MoreIdentityResponse {
        message IdentityFields {
          repeated string fields = 1;
        }

        optional bytes encryptedIdentityFields = 1;
      } // TODO: encryption


// messaging.md:220
      message MatchCompleteResponse {
      }


// messaging.md:234
    message SecondWhistle {
      optional bytes queryId = 1;
      // TODO: how do we ensure this comes from the SP??
    }


// messaging.md:245
        message QueryAnswer {
          optional bytes queryId = 1;
          oneof result {
            ValueResponse value = 2;
            ErrorResponse error = 3;
          }
        }


// messaging.md:257
        message ValueResponse {
          // TODO: how do we represent this?
          // TODO: attribute standards fields, e.g. currency, expiry
        }


// messaging.md:266
        message ErrorResponse {
          // TODO
        }


// messaging.md:274
        message Finish {
          optional bytes queryId = 1;
        }


////////////////////////////////////////////////////////////////////////////////

